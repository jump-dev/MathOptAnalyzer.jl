var documenterSearchIndex = {"docs":
[{"location":"analyzer/#MathOptAnalyzer-main-API","page":"MathOptAnalyzer main API","title":"MathOptAnalyzer main API","text":"All the analysis modules in MathOptAnalyzer follow the same main API. The main function to perform an analysis is:\n\nOnce the analysis is performed, the resulting data structure can be summarized using:\n\nAlternatively, you can also query the types of issues found in the analysis and summarize them individually. The following functions are useful for this:\n\nIt is possible to extract data from the issues with the methods:","category":"section"},{"location":"analyzer/#MathOptAnalyzer.analyze","page":"MathOptAnalyzer main API","title":"MathOptAnalyzer.analyze","text":"analyze(analyzer::AbstractAnalyzer, model::JuMP.GenericModel; kwargs...)\n\nAnalyze a JuMP model using the specified analyzer. Depending on the analyzer, this keyword arguments might vary. This function will return an instance of AbstractData which contains the results of the analysis that can be further summarized or queried for issues.\n\nSee summarize, list_of_issues, and list_of_issue_types.\n\n\n\n\n\n","category":"function"},{"location":"analyzer/#MathOptAnalyzer.summarize","page":"MathOptAnalyzer main API","title":"MathOptAnalyzer.summarize","text":"summarize([io::IO,] AbstractData; model = nothing, verbose = true, max_issues = 10, kwargs...)\n\nPrint a summary of the analysis results contained in AbstractData to the specified IO stream. If no IO stream is provided, it defaults to stdout. The model that led to the issue can be provided to model, it will be used to generate the name of variables and constraints in the issue summary. The verbose flag controls whether to print detailed information about each issue (if true) or a concise summary (if false). The max_issues argument controls the maximum number of issues to display in the summary. If there are more issues than max_issues, only the first max_issues will be displayed.\n\nsummarize([io::IO,] ::Type{T}; verbose = true) where {T<:AbstractIssue}\n\nThis variant allows summarizing information of a specific type T (which must be a subtype of AbstractIssue). In the verbose case it will provide a text explaning the issue. In the non-verbose case it will provide just the issue name.\n\nsummarize([io::IO,] issue::AbstractIssue; model = nothing, verbose = true)\n\nThis variant allows summarizing a single issue instance of type AbstractIssue. The model that led to the issue can be provided to model, it will be used to generate the name of variables and constraints in the issue summary.\n\n\n\n\n\n","category":"function"},{"location":"analyzer/#MathOptAnalyzer.list_of_issue_types","page":"MathOptAnalyzer main API","title":"MathOptAnalyzer.list_of_issue_types","text":"list_of_issue_types(data::AbstractData)\n\nReturn a vector of DataType containing the types of issues found in the analysis results contained in data.\n\n\n\n\n\n","category":"function"},{"location":"analyzer/#MathOptAnalyzer.list_of_issues","page":"MathOptAnalyzer main API","title":"MathOptAnalyzer.list_of_issues","text":"list_of_issues(data::AbstractData, issue_type::Type{T}) where {T<:AbstractIssue}\n\nReturn a vector of instances of T (which must be a subtype of AbstractIssue) found in the analysis results contained in data. This allows you to retrieve all instances of a specific issue type from the analysis results.\n\n\n\n\n\n","category":"function"},{"location":"analyzer/#MathOptAnalyzer.variables","page":"MathOptAnalyzer main API","title":"MathOptAnalyzer.variables","text":"variables(issue::AbstractIssue)\n\nReturn the variables associated to a particular issue.\n\n\n\n\n\nvariables(issue::MathOptAnalyzer.AbstractIssue, model::JuMP.GenericModel)\n\nReturn the JuMP variable references associated to a particular issue.\n\n\n\n\n\n","category":"function"},{"location":"analyzer/#MathOptAnalyzer.variable","page":"MathOptAnalyzer main API","title":"MathOptAnalyzer.variable","text":"variable(issue::AbstractIssue)\n\nReturn the variable associated to a particular issue.\n\n\n\n\n\nvariable(issue::MathOptAnalyzer.AbstractIssue, model::JuMP.GenericModel)\n\nReturn the JuMP variable reference associated to a particular issue.\n\n\n\n\n\n","category":"function"},{"location":"analyzer/#MathOptAnalyzer.constraints","page":"MathOptAnalyzer main API","title":"MathOptAnalyzer.constraints","text":"constraints(issue::AbstractIssue)\n\nReturn the constraints associated to a particular issue.\n\n\n\n\n\nconstraintss(issue::MathOptAnalyzer.AbstractIssue, model::JuMP.GenericModel)\n\nReturn the JuMP constraints reference associated to a particular issue.\n\n\n\n\n\n","category":"function"},{"location":"analyzer/#MathOptAnalyzer.constraint","page":"MathOptAnalyzer main API","title":"MathOptAnalyzer.constraint","text":"constraint(issue::AbstractIssue)\n\nReturn the constraint associated to a particular issue.\n\n\n\n\n\nconstraint(issue::MathOptAnalyzer.AbstractIssue, model::JuMP.GenericModel)\n\nReturn the JuMP constraint reference associated to a particular issue.\n\n\n\n\n\n","category":"function"},{"location":"analyzer/#MathOptAnalyzer.set","page":"MathOptAnalyzer main API","title":"MathOptAnalyzer.set","text":"set(issue::AbstractIssue)\n\nReturn the set associated to a particular issue.\n\n\n\n\n\n","category":"function"},{"location":"analyzer/#MathOptAnalyzer.values","page":"MathOptAnalyzer main API","title":"MathOptAnalyzer.values","text":"values(issue::AbstractIssue)\n\nReturn the values associated to a particular issue.\n\n\n\n\n\n","category":"function"},{"location":"analyzer/#MathOptAnalyzer.value","page":"MathOptAnalyzer main API","title":"MathOptAnalyzer.value","text":"value(issue::AbstractIssue)\n\nReturn the value associated to a particular issue. The value is a number with a different meaning depending on the type of issue. For example, for some numerical issues, it can be the coefficient value.\n\n\n\n\n\n","category":"function"},{"location":"feasibility/#Feasibility-Analysis","page":"Feasibility Analysis","title":"Feasibility Analysis","text":"This module provides functionality to perform feasibility analysis on a JuMP model. This module follows the main API and is activated by the struct:\n\nThe analysis will return issues of the abstract type:\n\nSpecifically, the possible issues are:\n\nThese issues are saved in the data structure that is returned from the MathOptAnalyzer.analyze function:","category":"section"},{"location":"feasibility/#MathOptAnalyzer.Feasibility.Analyzer","page":"Feasibility Analysis","title":"MathOptAnalyzer.Feasibility.Analyzer","text":"Analyzer() <: MathOptAnalyzer.AbstractAnalyzer\n\nThe Analyzer type is used to perform feasibility analysis on a model.\n\nExample\n\njulia> data = MathOptAnalyzer.analyze(\n    MathOptAnalyzer.Feasibility.Analyzer(),\n    model;\n    primal_point::Union{Nothing, Dict} = nothing,\n    dual_point::Union{Nothing, Dict} = nothing,\n    primal_objective::Union{Nothing, Float64} = nothing,\n    dual_objective::Union{Nothing, Float64} = nothing,\n    atol::Float64 = 1e-6,\n    skip_missing::Bool = false,\n    dual_check::Bool = true,\n);\n\nThe additional parameters:\n\nprimal_point: The primal solution point to use for feasibility checking. If nothing, it will use the current primal solution from optimized model.\ndual_point: The dual solution point to use for feasibility checking. If nothing and the model can be dualized, it will use the current dual solution from the model.\nprimal_objective: The primal objective value considered as the solver objective. If nothing, it will use the current primal objective value from the model (solver).\ndual_objective: The dual objective value considered as the solver objective. If nothing, it will use the current dual objective value from the model (solver).\natol: The absolute tolerance for feasibility checking.\nskip_missing: If true, constraints with missing variables in the provided point will be ignored.\ndual_check: If true, it will perform dual feasibility checking if the model is compatible with Dualization.jl. Disabling the dual check will also disable complementarity checking and dual objective checks.\n\n\n\n\n\n","category":"type"},{"location":"feasibility/#MathOptAnalyzer.Feasibility.AbstractFeasibilityIssue","page":"Feasibility Analysis","title":"MathOptAnalyzer.Feasibility.AbstractFeasibilityIssue","text":"AbstractFeasibilityIssue <: AbstractNumericalIssue\n\nAbstract type for feasibility issues found during the analysis of a model.\n\n\n\n\n\n","category":"type"},{"location":"feasibility/#MathOptAnalyzer.Feasibility.PrimalViolation","page":"Feasibility Analysis","title":"MathOptAnalyzer.Feasibility.PrimalViolation","text":"PrimalViolation <: AbstractFeasibilityIssue\n\nThe PrimalViolation issue is identified when a primal constraint has a left-hand-side value that is not within the constraint's set.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Feasibility.PrimalViolation)\n\n\n\n\n\n","category":"type"},{"location":"feasibility/#MathOptAnalyzer.Feasibility.DualConstraintViolation","page":"Feasibility Analysis","title":"MathOptAnalyzer.Feasibility.DualConstraintViolation","text":"DualConstraintViolation <: AbstractFeasibilityIssue\n\nThe DualConstraintViolation issue is identified when a dual constraint has a value that is not within the dual constraint's set. This dual constraint corresponds to a primal variable.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Feasibility.DualConstraintViolation)\n\n\n\n\n\n","category":"type"},{"location":"feasibility/#MathOptAnalyzer.Feasibility.DualConstrainedVariableViolation","page":"Feasibility Analysis","title":"MathOptAnalyzer.Feasibility.DualConstrainedVariableViolation","text":"DualConstrainedVariableViolation <: AbstractFeasibilityIssue\n\nThe DualConstrainedVariableViolation issue is identified when a dual constraint, which is a constrained varaible constraint, has a value that is not within the dual constraint's set. During the dualization  process, each primal constraint is mapped to a dual variable, this dual variable is tipically a constrained variable with the dual set of the primal constraint. If the primal constraint is a an equality type constraint, the dual variable is a free variable, hence, not constrained (dual) variable. This dual constraint corresponds to a primal (non-equality) constraint.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Feasibility.DualConstrainedVariableViolation)\n\n\n\n\n\n","category":"type"},{"location":"feasibility/#MathOptAnalyzer.Feasibility.ComplemetarityViolation","page":"Feasibility Analysis","title":"MathOptAnalyzer.Feasibility.ComplemetarityViolation","text":"ComplemetarityViolation <: AbstractFeasibilityIssue\n\nThe ComplemetarityViolation issue is identified when a pair of primal constraint and dual variable has a nonzero complementarity value, i.e., the inner product of the primal constraint's slack and the dual variable's violation is not zero.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Feasibility.ComplemetarityViolation)\n\n\n\n\n\n","category":"type"},{"location":"feasibility/#MathOptAnalyzer.Feasibility.DualObjectiveMismatch","page":"Feasibility Analysis","title":"MathOptAnalyzer.Feasibility.DualObjectiveMismatch","text":"DualObjectiveMismatch <: AbstractFeasibilityIssue\n\nThe DualObjectiveMismatch issue is identified when the dual objective value computed from problem data and the dual solution does not match the solver's dual objective value.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Feasibility.DualObjectiveMismatch)\n\n\n\n\n\n","category":"type"},{"location":"feasibility/#MathOptAnalyzer.Feasibility.PrimalObjectiveMismatch","page":"Feasibility Analysis","title":"MathOptAnalyzer.Feasibility.PrimalObjectiveMismatch","text":"PrimalObjectiveMismatch <: AbstractFeasibilityIssue\n\nThe PrimalObjectiveMismatch issue is identified when the primal objective value computed from problem data and the primal solution does not match the solver's primal objective value.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Feasibility.PrimalObjectiveMismatch)\n\n\n\n\n\n","category":"type"},{"location":"feasibility/#MathOptAnalyzer.Feasibility.PrimalDualMismatch","page":"Feasibility Analysis","title":"MathOptAnalyzer.Feasibility.PrimalDualMismatch","text":"PrimalDualMismatch <: AbstractFeasibilityIssue\n\nThe PrimalDualMismatch issue is identified when the primal objective value computed from problem data and the primal solution does not match the dual objective value computed from problem data and the dual solution.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Feasibility.PrimalDualMismatch)\n\n\n\n\n\n","category":"type"},{"location":"feasibility/#MathOptAnalyzer.Feasibility.PrimalDualSolverMismatch","page":"Feasibility Analysis","title":"MathOptAnalyzer.Feasibility.PrimalDualSolverMismatch","text":"PrimalDualSolverMismatch <: AbstractFeasibilityIssue\n\nThe PrimalDualSolverMismatch issue is identified when the primal objective value reported by the solver does not match the dual objective value reported by the solver.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Feasibility.PrimalDualSolverMismatch)\n\n\n\n\n\n","category":"type"},{"location":"feasibility/#MathOptAnalyzer.Feasibility.Data","page":"Feasibility Analysis","title":"MathOptAnalyzer.Feasibility.Data","text":"Data\n\nThe Data structure holds the results of the feasibility analysis performed by the MathOptAnalyzer.analyze function for a model. It contains the configuration used for the analysis, the primal and dual points, and the lists of various feasibility issues found during the analysis.\n\n\n\n\n\n","category":"type"},{"location":"infeasibility/#Infeasibility-Analysis","page":"Infeasibility Analysis","title":"Infeasibility Analysis","text":"This module provides functionality to perform infeasibility analysis on a JuMP model. This module follows the main API and is activated by the struct:\n\nThe analysis will return issues of the abstract type:\n\nSpecifically, the possible issues are:\n\nThese issues are saved in the data structure that is returned from the MathOptAnalyzer.analyze function:","category":"section"},{"location":"infeasibility/#MathOptAnalyzer.Infeasibility.Analyzer","page":"Infeasibility Analysis","title":"MathOptAnalyzer.Infeasibility.Analyzer","text":"Analyzer() <: MathOptAnalyzer.AbstractAnalyzer\n\nThe Analyzer type is used to perform infeasibility analysis on a model.\n\nExample\n\njulia> data = MathOptAnalyzer.analyze(\n    Analyzer(),\n    model,\n    optimizer = nothing,,\n)\n\nThe additional keyword argument optimizer is used to specify the optimizer to use for the IIS resolver.\n\n\n\n\n\n","category":"type"},{"location":"infeasibility/#MathOptAnalyzer.Infeasibility.AbstractInfeasibilitylIssue","page":"Infeasibility Analysis","title":"MathOptAnalyzer.Infeasibility.AbstractInfeasibilitylIssue","text":"AbstractInfeasibilitylIssue\n\nAbstract type for infeasibility issues found during the analysis of a model.\n\n\n\n\n\n","category":"type"},{"location":"infeasibility/#MathOptAnalyzer.Infeasibility.InfeasibleBounds","page":"Infeasibility Analysis","title":"MathOptAnalyzer.Infeasibility.InfeasibleBounds","text":"InfeasibleBounds{T} <: AbstractInfeasibilitylIssue\n\nThe InfeasibleBounds issue is identified when a variable has a lower bound that is greater than its upper bound.\n\nFor more information, run: julia julia> MathOptAnalyzer.summarize(MathOptAnalyzer.Infeasibility.InfeasibleBounds)`\n\n\n\n\n\n","category":"type"},{"location":"infeasibility/#MathOptAnalyzer.Infeasibility.InfeasibleIntegrality","page":"Infeasibility Analysis","title":"MathOptAnalyzer.Infeasibility.InfeasibleIntegrality","text":"InfeasibleIntegrality{T} <: AbstractInfeasibilitylIssue\n\nThe InfeasibleIntegrality issue is identified when a variable has an integrality constraint (like MOI.Integer or MOI.ZeroOne) that is not consistent with its bounds. That is, the bounds do not allow for any integer value to be feasible.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(\n    MathOptAnalyzer.Infeasibility.InfeasibleIntegrality\n)\n\n\n\n\n\n","category":"type"},{"location":"infeasibility/#MathOptAnalyzer.Infeasibility.InfeasibleConstraintRange","page":"Infeasibility Analysis","title":"MathOptAnalyzer.Infeasibility.InfeasibleConstraintRange","text":"InfeasibleConstraintRange{T} <: AbstractInfeasibilitylIssue\n\nThe InfeasibleConstraintRange issue is identified when a constraint cannot be satisfied given the variable bounds. This analysis only considers one constraint at a time and all variable bounds of variables involved in the constraint. This issue can only be found is all variable bounds are consistent, that is, no issues of type InfeasibleBounds were found in the first layer of analysis.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(\n    MathOptAnalyzer.Infeasibility.InfeasibleConstraintRange\n)\n\n\n\n\n\n","category":"type"},{"location":"infeasibility/#MathOptAnalyzer.Infeasibility.IrreducibleInfeasibleSubset","page":"Infeasibility Analysis","title":"MathOptAnalyzer.Infeasibility.IrreducibleInfeasibleSubset","text":"IrreducibleInfeasibleSubset <: AbstractInfeasibilitylIssue\n\nThe IrreducibleInfeasibleSubset issue is identified when a subset of constraints cannot be satisfied simultaneously. This is typically found by the IIS resolver after the first two layers of infeasibility analysis have been completed with no issues, that is, no issues of any other type were found.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(\n    MathOptAnalyzer.Infeasibility.IrreducibleInfeasibleSubset\n)\n\n\n\n\n\n","category":"type"},{"location":"infeasibility/#MathOptAnalyzer.Infeasibility.Data","page":"Infeasibility Analysis","title":"MathOptAnalyzer.Infeasibility.Data","text":"Data <: MathOptAnalyzer.AbstractData\n\nThe Data type is used to store the results of the infeasibility analysis. This type contains vectors of the various infeasibility issues found during the analysis, including InfeasibleBounds, InfeasibleIntegrality, InfeasibleConstraintRange, and IrreducibleInfeasibleSubset.\n\n\n\n\n\n","category":"type"},{"location":"numerical/#Numerical-Analysis","page":"Numerical Analysis","title":"Numerical Analysis","text":"This module provides functionality to perform numerical analysis on a JuMP model. This module follows the main API and is activated by the struct:\n\nThe analysis will return issues of the abstract type:\n\nSpecifically the possible issues are:\n\nThese issues are saved in the data structure that is returned from the MathOptAnalyzer.analyze function:","category":"section"},{"location":"numerical/#MathOptAnalyzer.Numerical.Analyzer","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.Analyzer","text":"Analyzer() <: MathOptAnalyzer.AbstractAnalyzer\n\nThe Analyzer type is used to analyze the coefficients of a model for numerical issues.\n\nExample\n\njulia> data = MathOptAnalyzer.analyze(\n    MathOptAnalyzer.Numerical.Analyzer(),\n    model;\n    threshold_dense_fill_in = 0.10,\n    threshold_dense_entries = 1000,\n    threshold_small = 1e-5,\n    threshold_large = 1e+5,\n    threshold_dynamic_range_single = 1e+6,\n    threshold_dynamic_range_matrix = 1e+8,\n)\n\nThe additional parameters:\n\nthreshold_dense_fill_in: The threshold for the fraction of non-zero entries in a constraint to be considered dense.\nthreshold_dense_entries: The minimum number of non-zero entries for a constraint to be considered dense.\nthreshold_small: The threshold for small coefficients in the model.\nthreshold_large: The threshold for large coefficients in the model.\nthreshold_dynamic_range_single: The threshold for the range of coefficients in the model with respect with individual columns, rows, objective coefficients and rhs coefficients.\nthreshold_dynamic_range_matrix: The threshold for the range of coefficients in the model with respect to the matrix of coefficients.\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.AbstractNumericalIssue","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.AbstractNumericalIssue","text":"AbstractNumericalIssue <: AbstractNumericalIssue\n\nAbstract type for numerical issues found during the analysis of a model.\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.VariableNotInConstraints","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.VariableNotInConstraints","text":"VariableNotInConstraints <: AbstractNumericalIssue\n\nThe VariableNotInConstraints issue is identified when a variable appears in no constraints.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Numerical.VariableNotInConstraints)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.EmptyConstraint","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.EmptyConstraint","text":"EmptyConstraint <: AbstractNumericalIssue\n\nThe EmptyConstraint issue is identified when a constraint has no coefficients different from zero.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Numerical.EmptyConstraint)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.VariableBoundAsConstraint","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.VariableBoundAsConstraint","text":"VariableBoundAsConstraint <: AbstractNumericalIssue\n\nThe VariableBoundAsConstraint issue is identified when a constraint is equivalent to a variable bound, that is, the constraint has only one non-zero coefficient, and this coefficient is equal to one.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Numerical.VariableBoundAsConstraint)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.DenseConstraint","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.DenseConstraint","text":"DenseConstraint <: AbstractNumericalIssue\n\nThe DenseConstraint issue is identified when a constraint has a fraction of non-zero entries greater than threshold_dense_fill_in and the number of non-zero entries is greater than threshold_dense_entries.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Numerical.DenseConstraint)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.SmallMatrixCoefficient","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.SmallMatrixCoefficient","text":"SmallMatrixCoefficient <: AbstractNumericalIssue\n\nThe SmallMatrixCoefficient issue is identified when a matrix coefficient in a constraint is smaller than threshold_small.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Numerical.SmallMatrixCoefficient)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.LargeMatrixCoefficient","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.LargeMatrixCoefficient","text":"LargeMatrixCoefficient <: AbstractNumericalIssue\n\nThe LargeMatrixCoefficient issue is identified when a matrix coefficient in a constraint is larger than threshold_large.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Numerical.LargeMatrixCoefficient)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.SmallBoundCoefficient","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.SmallBoundCoefficient","text":"SmallBoundCoefficient <: AbstractNumericalIssue\n\nThe SmallBoundCoefficient issue is identified when a variable's bound (coefficient) is smaller than threshold_small.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Numerical.SmallBoundCoefficient)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.LargeBoundCoefficient","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.LargeBoundCoefficient","text":"LargeBoundCoefficient <: AbstractNumericalIssue\n\nThe LargeBoundCoefficient issue is identified when a variable's bound (coefficient) is larger than threshold_large.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Numerical.LargeBoundCoefficient)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.SmallRHSCoefficient","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.SmallRHSCoefficient","text":"SmallRHSCoefficient <: AbstractNumericalIssue\n\nThe SmallRHSCoefficient issue is identified when the right-hand-side (RHS) coefficient of a constraint is smaller than threshold_small.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Numerical.SmallRHSCoefficient)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.LargeRHSCoefficient","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.LargeRHSCoefficient","text":"LargeRHSCoefficient <: AbstractNumericalIssue\n\nThe LargeRHSCoefficient issue is identified when the right-hand-side (RHS) coefficient of a constraint is larger than threshold_large.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Numerical.LargeRHSCoefficient)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.SmallObjectiveCoefficient","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.SmallObjectiveCoefficient","text":"SmallObjectiveCoefficient <: AbstractNumericalIssue\n\nThe SmallObjectiveCoefficient issue is identified when a coefficient in the objective function is smaller than threshold_small.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Numerical.SmallObjectiveCoefficient)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.LargeObjectiveCoefficient","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.LargeObjectiveCoefficient","text":"LargeObjectiveCoefficient <: AbstractNumericalIssue\n\nThe LargeObjectiveCoefficient issue is identified when a coefficient in the objective function is larger than threshold_large.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(MathOptAnalyzer.Numerical.LargeObjectiveCoefficient)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.SmallObjectiveQuadraticCoefficient","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.SmallObjectiveQuadraticCoefficient","text":"SmallObjectiveQuadraticCoefficient <: AbstractNumericalIssue\n\nThe SmallObjectiveQuadraticCoefficient issue is identified when a quadratic coefficient in the objective function is smaller than threshold_small.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(\n    MathOptAnalyzer.Numerical.SmallObjectiveQuadraticCoefficient\n)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.LargeObjectiveQuadraticCoefficient","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.LargeObjectiveQuadraticCoefficient","text":"LargeObjectiveQuadraticCoefficient <: AbstractNumericalIssue\n\nThe LargeObjectiveQuadraticCoefficient issue is identified when a quadratic coefficient in the objective function is larger than threshold_large.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(\n    MathOptAnalyzer.Numerical.LargeObjectiveQuadraticCoefficient\n)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.SmallMatrixQuadraticCoefficient","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.SmallMatrixQuadraticCoefficient","text":"SmallMatrixQuadraticCoefficient <: AbstractNumericalIssue\n\nThe SmallMatrixQuadraticCoefficient issue is identified when a quadratic coefficient in a constraint is smaller than threshold_small.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(\n    MathOptAnalyzer.Numerical.SmallMatrixQuadraticCoefficient\n)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.LargeMatrixQuadraticCoefficient","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.LargeMatrixQuadraticCoefficient","text":"LargeMatrixQuadraticCoefficient <: AbstractNumericalIssue\n\nThe LargeMatrixQuadraticCoefficient issue is identified when a quadratic coefficient in a constraint is larger than threshold_large.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(\n    MathOptAnalyzer.Numerical.LargeMatrixQuadraticCoefficient\n)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.NonconvexQuadraticObjective","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.NonconvexQuadraticObjective","text":"NonconvexQuadraticObjective <: AbstractNumericalIssue\n\nThe NonconvexQuadraticObjective issue is identified when a quadratic objective function is non-convex.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(\n    MathOptAnalyzer.Numerical.NonconvexQuadraticObjective\n)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.NonconvexQuadraticConstraint","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.NonconvexQuadraticConstraint","text":"NonconvexQuadraticConstraint\n\nThe NonconvexQuadraticConstraint issue is identified when a quadratic constraint is non-convex.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(\n    MathOptAnalyzer.Numerical.NonconvexQuadraticConstraint\n)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.LargeDynamicRangeConstraint","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.LargeDynamicRangeConstraint","text":"LargeDynamicRangeConstraint <: AbstractNumericalIssue\n\nThe LargeDynamicRangeConstraint issue is identified when the dynamic range of a constraint is larger than threshold_dynamic_range_single. The dynamic range is defined as the ratio between the largest and smallest coefficients of the constraint.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(\n    MathOptAnalyzer.Numerical.LargeDynamicRangeConstraint\n)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.LargeDynamicRangeMatrix","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.LargeDynamicRangeMatrix","text":"LargeDynamicRangeMatrix <: AbstractNumericalIssue\n\nThe LargeDynamicRangeMatrix issue is identified when the dynamic range of the matrix is larger than threshold_dynamic_range_matrix. The dynamic range is defined as the ratio between the largest and smallest coefficients of the matrix.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(\n    MathOptAnalyzer.Numerical.LargeDynamicRangeMatrix\n)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.LargeDynamicRangeObjective","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.LargeDynamicRangeObjective","text":"LargeDynamicRangeObjective <: AbstractNumericalIssue\n\nThe LargeDynamicRangeObjective issue is identified when the dynamic range of the objective function is larger than threshold_dynamic_range_single. The dynamic range is defined as the ratio between the largest and smallest coefficients of the objective function.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(\n    MathOptAnalyzer.Numerical.LargeDynamicRangeObjective\n)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.LargeDynamicRangeRHS","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.LargeDynamicRangeRHS","text":"LargeDynamicRangeRHS <: AbstractNumericalIssue\n\nThe LargeDynamicRangeRHS issue is identified when the dynamic range of the right-hand side (RHS) vector is larger than threshold_dynamic_range_rhs. The dynamic range is defined as the ratio between the largest and smallest coefficients of the RHS vector.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(\n    MathOptAnalyzer.Numerical.LargeDynamicRangeRHS\n)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.LargeDynamicRangeVariable","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.LargeDynamicRangeVariable","text":"LargeDynamicRangeVariable <: AbstractNumericalIssue\n\nThe LargeDynamicRangeVariable issue is identified when the dynamic range of a variable is larger than threshold_dynamic_range_single. The dynamic range is defined as the ratio between the largest and smallest coefficients of the variable inall constraint it appears.\n\nFor more information, run:\n\njulia> MathOptAnalyzer.summarize(\n    MathOptAnalyzer.Numerical.LargeDynamicRangeVariable\n)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.LargeDynamicRangeBound","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.LargeDynamicRangeBound","text":"LargeDynamicRangeBound <: AbstractNumericalIssue\n\nThe LargeDynamicRangeBound issue is identified when the dynamic range of the variables bounds is larger than threshold_dynamic_range_single. The dynamic range is defined as the ratio between the largest and smallest bounds of all variables. For more information, run:\n\njulia> MathOptAnalyzer.summarize(\n    MathOptAnalyzer.Numerical.LargeDynamicRangeBound\n)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#MathOptAnalyzer.Numerical.Data","page":"Numerical Analysis","title":"MathOptAnalyzer.Numerical.Data","text":"Data\n\nThe Data structure holds the results of the analysis performed by the MathOptAnalyzer.Numerical.Analyzer. It contains various thresholds and the information about the model's variables, constraints, and objective function.\n\n\n\n\n\n","category":"type"},{"location":"#MathOptAnalyzer.jl","page":"MathOptAnalyzer.jl","title":"MathOptAnalyzer.jl","text":"This package provides tools for analyzing (and debugging) JuMP models.\n\nThree main functionalities are provided:\n\nNumerical Analysis: Check for numerical issues in the model, such as large and small coefficients, empty constraints, non-convex quadratic functions.\nFeasibility Analysis: Given an optimized model, or a candidate solution, check if the solutions is feasible and optimal (when possible). This includes checking the feasibility of the primal model and also the dual model (if available). Complementary slackness conditions are also checked (if applicable).\nInfeasibility Analysis: Given an unsolved of solved model, three steps are made to check for infeasibility:\nCheck bounds, integers and binaries consistency is also checked at this point.\nPropagate bounds in constraints individually, to check if each constraint is infeasible given the current variable bounds. This is only done if bounds are ok.\nRun an IIS (Irreducible Inconsistent Subsystem / irreducible infeasible sets) resolver algorithm to find a minimal infeasible subset of constraints. This is only done if no issues are found in the previous two steps.","category":"section"},{"location":"#Installation","page":"MathOptAnalyzer.jl","title":"Installation","text":"You can install the package using the Julia package manager. In the Julia REPL, run:\n\nusing Pkg\nPkg.add(\"MathOptAnalyzer\")","category":"section"},{"location":"#Usage","page":"MathOptAnalyzer.jl","title":"Usage","text":"","category":"section"},{"location":"#Basic-usage","page":"MathOptAnalyzer.jl","title":"Basic usage","text":"Here is a simple example of how to use the package:\n\nusing JuMP\nusing MathOptAnalyzer\nusing HiGHS # or any other supported solver\n# Create a simple JuMP model\nmodel = Model(HiGHS.Optimizer)\n@variable(model, x >= 0)\n@variable(model, y >= 0)\n@constraint(model, c1, 2x + 3y == 5)\n@constraint(model, c2, x + 2y <= 3)\n@objective(model, Min, x + y)\n# Optimize the model\noptimize!(model)\n\n# either\n\n# Perform a numerical analysis of the model\ndata = MathOptAnalyzer.analyze(MathOptAnalyzer.Numerical.Analyzer(), model)\n# print report\nMathOptAnalyzer.summarize(data)\n\n# or\n\n# Check for solution feasibility and optimality\ndata = MathOptAnalyzer.analyze(MathOptAnalyzer.Feasibility.Analyzer(), model)\n# print report\nMathOptAnalyzer.summarize(data)\n\n# or\n\n# Infeasibility analysis (if the model was infeasible)\ndata = MathOptAnalyzer.analyze(\n    MathOptAnalyzer.Infeasibility.Analyzer(),\n    model,\n    optimizer = HiGHS.Optimizer,\n)\n\n# print report to the screen\nMathOptAnalyzer.summarize(data)\n\n# or print the report to a file\n\n# open a file\nopen(\"my_report.txt\", \"w\") do io\n    # print report\n    MathOptAnalyzer.summarize(io, data)\nend\n\nThe MathOptAnalyzer.analyze(...) function can always take the keyword arguments:\n\nverbose = false to condense the print output.\nmax_issues = n to limit the maximum number of issues to report for each type.\n\nFor certain analysis modes, the summarize function can take additional arguments.","category":"section"},{"location":"#Advanced-usage","page":"MathOptAnalyzer.jl","title":"Advanced usage","text":"After any MathOptAnalyzer.analyze(...) call is performed, the resulting data structure can be summarized using MathOptAnalyzer.summarize(data) as show above, or it can be further inspected programmatically.\n\n# given a `data` object obtained from `MathOptAnalyzer.analyze(...)`\n\n# query the types of issues found in the analysis\nlist = MathOptAnalyzer.list_of_issue_types(data)\n\n# information about the types of issues found can be printed out\nMathOptAnalyzer.summarize(list[1])\n\n# for each issue type, you can get the actual issues found in the analysis\nissues = MathOptAnalyzer.list_of_issues(data, list[1])\n\n# the list of issues of the given type can be summarized with:\nMathOptAnalyzer.summarize(issues)\n\n# individual issues can also be summarized\nMathOptAnalyzer.summarize(issues[1])","category":"section"},{"location":"#Non-JuMP-(or-MOI)-models","page":"MathOptAnalyzer.jl","title":"Non JuMP (or MOI) models","text":"If you don't have a JuMP (or MOI) model, you can still use this package reading from a file.\n\nGiven a file that could have been generated by JuMP or not, such as:\n\nmodel = Model();\n@variable(model, x >= 0);\n@objective(model, Min, 2 * x + 1);\nfilename = joinpath(mktempdir(), \"model.mps\");\nwrite_to_file(model, filename; generic_names = true)\n\nWe can read it with JuMP:\n\nfilename = joinpath(mktempdir(), \"model.mps\");\nnew_model = read_from_file(filename)\nprint(new_model)\n\nAnd then proceed with the analysis described above.","category":"section"}]
}
