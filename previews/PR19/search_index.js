var documenterSearchIndex = {"docs":
[{"location":"analyzer/#ModelAnalyzer-main-API","page":"ModelAnalyzer main API","title":"ModelAnalyzer main API","text":"","category":"section"},{"location":"analyzer/","page":"ModelAnalyzer main API","title":"ModelAnalyzer main API","text":"All the analysis modules in ModelAnalyzer follow the same main API. The main function to perform an analysis is:","category":"page"},{"location":"analyzer/#ModelAnalyzer.analyze","page":"ModelAnalyzer main API","title":"ModelAnalyzer.analyze","text":"analyze(analyzer::AbstractAnalyzer, model::JuMP.GenericModel; kwargs...)\n\nAnalyze a JuMP model using the specified analyzer. Depending on the analyzer, this keyword arguments might vary. This function will return an instance of AbstractData which contains the results of the analysis that can be further summarized or queried for issues.\n\nSee summarize, list_of_issues, and list_of_issue_types.\n\n\n\n\n\n","category":"function"},{"location":"analyzer/","page":"ModelAnalyzer main API","title":"ModelAnalyzer main API","text":"Once the analysis is performed, the resulting data structure can be summarized using:","category":"page"},{"location":"analyzer/#ModelAnalyzer.summarize","page":"ModelAnalyzer main API","title":"ModelAnalyzer.summarize","text":"summarize([io::IO,] AbstractData; model = nothing, verbose = true, max_issues = 10, kwargs...)\n\nPrint a summary of the analysis results contained in AbstractData to the specified IO stream. If no IO stream is provided, it defaults to stdout. The model that led to the issue can be provided to model, it will be used to generate the name of variables and constraints in the issue summary. The verbose flag controls whether to print detailed information about each issue (if true) or a concise summary (if false). The max_issues argument controls the maximum number of issues to display in the summary. If there are more issues than max_issues, only the first max_issues will be displayed.\n\nsummarize([io::IO,] ::Type{T}; verbose = true) where {T<:AbstractIssue}\n\nThis variant allows summarizing information of a specific type T (which must be a subtype of AbstractIssue). In the verbose case it will provide a text explaning the issue. In the non-verbose case it will provide just the issue name.\n\nsummarize([io::IO,] issue::AbstractIssue; model = nothing, verbose = true)\n\nThis variant allows summarizing a single issue instance of type AbstractIssue. The model that led to the issue can be provided to model, it will be used to generate the name of variables and constraints in the issue summary.\n\n\n\n\n\n","category":"function"},{"location":"analyzer/","page":"ModelAnalyzer main API","title":"ModelAnalyzer main API","text":"Alternatively, you can also query the types of issues found in the analysis and summarize them individually. The following functions are useful for this:","category":"page"},{"location":"analyzer/#ModelAnalyzer.list_of_issue_types","page":"ModelAnalyzer main API","title":"ModelAnalyzer.list_of_issue_types","text":"list_of_issue_types(data::AbstractData)\n\nReturn a vector of DataType containing the types of issues found in the analysis results contained in data.\n\n\n\n\n\n","category":"function"},{"location":"analyzer/#ModelAnalyzer.list_of_issues","page":"ModelAnalyzer main API","title":"ModelAnalyzer.list_of_issues","text":"list_of_issues(data::AbstractData, issue_type::Type{T}) where {T<:AbstractIssue}\n\nReturn a vector of instances of T (which must be a subtype of AbstractIssue) found in the analysis results contained in data. This allows you to retrieve all instances of a specific issue type from the analysis results.\n\n\n\n\n\n","category":"function"},{"location":"feasibility/#Feasibility-Analysis","page":"Feasibility Analysis","title":"Feasibility Analysis","text":"","category":"section"},{"location":"feasibility/","page":"Feasibility Analysis","title":"Feasibility Analysis","text":"This module provides functionality to perform feasibility analysis on a JuMP model. This module follows the main API and is activated by the struct:","category":"page"},{"location":"feasibility/#ModelAnalyzer.Feasibility.Analyzer","page":"Feasibility Analysis","title":"ModelAnalyzer.Feasibility.Analyzer","text":"Analyzer() <: ModelAnalyzer.AbstractAnalyzer\n\nThe Analyzer type is used to perform feasibility analysis on a model.\n\nExample\n\njulia> data = ModelAnalyzer.analyze(\n    ModelAnalyzer.Feasibility.Analyzer(),\n    model;\n    primal_point::Union{Nothing, Dict} = nothing,\n    dual_point::Union{Nothing, Dict} = nothing,\n    atol::Float64 = 1e-6,\n    skip_missing::Bool = false,\n    dual_check = true,\n);\n\nThe additional parameters:\n\nprimal_point: The primal solution point to use for feasibility checking. If nothing, it will use the current primal solution from optimized model.\ndual_point: The dual solution point to use for feasibility checking. If nothing and the model can be dualized, it will use the current dual solution from the model.\natol: The absolute tolerance for feasibility checking.\nskip_missing: If true, constraints with missing variables in the provided point will be ignored.\ndual_check: If true, it will perform dual feasibility checking. Disabling the dual check will also disable complementarity checking.\n\n\n\n\n\n","category":"type"},{"location":"feasibility/","page":"Feasibility Analysis","title":"Feasibility Analysis","text":"The analysis will return issues of the abstract type:","category":"page"},{"location":"feasibility/#ModelAnalyzer.Feasibility.AbstractFeasibilityIssue","page":"Feasibility Analysis","title":"ModelAnalyzer.Feasibility.AbstractFeasibilityIssue","text":"AbstractFeasibilityIssue <: AbstractNumericalIssue\n\nAbstract type for feasibility issues found during the analysis of a model.\n\n\n\n\n\n","category":"type"},{"location":"feasibility/","page":"Feasibility Analysis","title":"Feasibility Analysis","text":"Specifically, the possible issues are:","category":"page"},{"location":"feasibility/#ModelAnalyzer.Feasibility.PrimalViolation","page":"Feasibility Analysis","title":"ModelAnalyzer.Feasibility.PrimalViolation","text":"PrimalViolation <: AbstractFeasibilityIssue\n\nThe PrimalViolation issue is identified when a primal constraint has a left-hand-side value that is not within the constraint's set.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Feasibility.PrimalViolation)\n\n\n\n\n\n","category":"type"},{"location":"feasibility/#ModelAnalyzer.Feasibility.DualConstraintViolation","page":"Feasibility Analysis","title":"ModelAnalyzer.Feasibility.DualConstraintViolation","text":"DualConstraintViolation <: AbstractFeasibilityIssue\n\nThe DualConstraintViolation issue is identified when a dual constraint has a value that is not within the dual constraint's set. This dual constraint corresponds to a primal variable.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Feasibility.DualConstraintViolation)\n\n\n\n\n\n","category":"type"},{"location":"feasibility/#ModelAnalyzer.Feasibility.DualConstrainedVariableViolation","page":"Feasibility Analysis","title":"ModelAnalyzer.Feasibility.DualConstrainedVariableViolation","text":"DualConstrainedVariableViolation <: AbstractFeasibilityIssue\n\nThe DualConstrainedVariableViolation issue is identified when a dual  constraint, which is a constrained varaible constraint, has a value that is not within the dual constraint's set. During the dualization  process, each primal constraint is mapped to a dual variable, this dual variable is tipically a constrained variable with the dual set of the primal constraint. If the primal constraint is a an equality type constraint, the dual variable is a free variable, hence, not constrained (dual) variable. This dual constraint corresponds to a primal (non-equality) constraint.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Feasibility.DualConstrainedVariableViolation)\n\n\n\n\n\n","category":"type"},{"location":"feasibility/#ModelAnalyzer.Feasibility.ComplemetarityViolation","page":"Feasibility Analysis","title":"ModelAnalyzer.Feasibility.ComplemetarityViolation","text":"ComplemetarityViolation <: AbstractFeasibilityIssue\n\nThe ComplemetarityViolation issue is identified when a pair of primal constraint and dual variable has a nonzero complementarity value, i.e., the inner product of the primal constraint's slack and the dual variable's violation is not zero.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Feasibility.ComplemetarityViolation)\n\n\n\n\n\n","category":"type"},{"location":"feasibility/#ModelAnalyzer.Feasibility.DualObjectiveMismatch","page":"Feasibility Analysis","title":"ModelAnalyzer.Feasibility.DualObjectiveMismatch","text":"DualObjectiveMismatch <: AbstractFeasibilityIssue\n\nThe DualObjectiveMismatch issue is identified when the dual objective value computed from problem data and the dual solution does not match the solver's dual objective value.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Feasibility.DualObjectiveMismatch)\n\n\n\n\n\n","category":"type"},{"location":"feasibility/#ModelAnalyzer.Feasibility.PrimalObjectiveMismatch","page":"Feasibility Analysis","title":"ModelAnalyzer.Feasibility.PrimalObjectiveMismatch","text":"PrimalObjectiveMismatch <: AbstractFeasibilityIssue\n\nThe PrimalObjectiveMismatch issue is identified when the primal objective value computed from problem data and the primal solution does not match the solver's primal objective value.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Feasibility.PrimalObjectiveMismatch)\n\n\n\n\n\n","category":"type"},{"location":"feasibility/#ModelAnalyzer.Feasibility.PrimalDualMismatch","page":"Feasibility Analysis","title":"ModelAnalyzer.Feasibility.PrimalDualMismatch","text":"PrimalDualMismatch <: AbstractFeasibilityIssue\n\nThe PrimalDualMismatch issue is identified when the primal objective value computed from problem data and the primal solution does not match the dual objective value computed from problem data and the dual solution.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Feasibility.PrimalDualMismatch)\n\n\n\n\n\n","category":"type"},{"location":"feasibility/#ModelAnalyzer.Feasibility.PrimalDualSolverMismatch","page":"Feasibility Analysis","title":"ModelAnalyzer.Feasibility.PrimalDualSolverMismatch","text":"PrimalDualSolverMismatch <: AbstractFeasibilityIssue\n\nThe PrimalDualSolverMismatch issue is identified when the primal objective value reported by the solver does not match the dual objective value reported by the solver.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Feasibility.PrimalDualSolverMismatch)\n\n\n\n\n\n","category":"type"},{"location":"feasibility/","page":"Feasibility Analysis","title":"Feasibility Analysis","text":"These issues are saved in the data structure that is returned from the ModelAnalyzer.analyze function:","category":"page"},{"location":"feasibility/#ModelAnalyzer.Feasibility.Data","page":"Feasibility Analysis","title":"ModelAnalyzer.Feasibility.Data","text":"Data\n\nThe Data structure holds the results of the feasibility analysis performed by the ModelAnalyzer.analyze function for a model. It contains the configuration used for the analysis, the primal and dual points, and the lists of various feasibility issues found during the analysis.\n\n\n\n\n\n","category":"type"},{"location":"infeasibility/#Infeasibility-Analysis","page":"Infeasibility Analysis","title":"Infeasibility Analysis","text":"","category":"section"},{"location":"infeasibility/","page":"Infeasibility Analysis","title":"Infeasibility Analysis","text":"This module provides functionality to perform infeasibility analysis on a JuMP model. This module follows the main API and is activated by the struct:","category":"page"},{"location":"infeasibility/#ModelAnalyzer.Infeasibility.Analyzer","page":"Infeasibility Analysis","title":"ModelAnalyzer.Infeasibility.Analyzer","text":"Analyzer() <: ModelAnalyzer.AbstractAnalyzer\n\nThe Analyzer type is used to perform infeasibility analysis on a model.\n\nExample\n\njulia> data = ModelAnalyzer.analyze(\n    Analyzer(),\n    model,\n    optimizer = nothing,,\n)\n\nThe additional keyword argument optimizer is used to specify the optimizer to use for the IIS resolver.\n\n\n\n\n\n","category":"type"},{"location":"infeasibility/","page":"Infeasibility Analysis","title":"Infeasibility Analysis","text":"The analysis will return issues of the abstract type:","category":"page"},{"location":"infeasibility/#ModelAnalyzer.Infeasibility.AbstractInfeasibilitylIssue","page":"Infeasibility Analysis","title":"ModelAnalyzer.Infeasibility.AbstractInfeasibilitylIssue","text":"AbstractInfeasibilitylIssue\n\nAbstract type for infeasibility issues found during the analysis of a model.\n\n\n\n\n\n","category":"type"},{"location":"infeasibility/","page":"Infeasibility Analysis","title":"Infeasibility Analysis","text":"Specifically, the possible issues are:","category":"page"},{"location":"infeasibility/#ModelAnalyzer.Infeasibility.InfeasibleBounds","page":"Infeasibility Analysis","title":"ModelAnalyzer.Infeasibility.InfeasibleBounds","text":"InfeasibleBounds{T} <: AbstractInfeasibilitylIssue\n\nThe InfeasibleBounds issue is identified when a variable has a lower bound that is greater than its upper bound.\n\nFor more information, run: julia julia> ModelAnalyzer.summarize(ModelAnalyzer.Infeasibility.InfeasibleBounds)`\n\n\n\n\n\n","category":"type"},{"location":"infeasibility/#ModelAnalyzer.Infeasibility.InfeasibleIntegrality","page":"Infeasibility Analysis","title":"ModelAnalyzer.Infeasibility.InfeasibleIntegrality","text":"InfeasibleIntegrality{T} <: AbstractInfeasibilitylIssue\n\nThe InfeasibleIntegrality issue is identified when a variable has an integrality constraint (like MOI.Integer or MOI.ZeroOne) that is not  consistent with its bounds. That is, the bounds do not allow for any integer value to be feasible.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(\n    ModelAnalyzer.Infeasibility.InfeasibleIntegrality\n)\n\n\n\n\n\n","category":"type"},{"location":"infeasibility/#ModelAnalyzer.Infeasibility.InfeasibleConstraintRange","page":"Infeasibility Analysis","title":"ModelAnalyzer.Infeasibility.InfeasibleConstraintRange","text":"InfeasibleConstraintRange{T} <: AbstractInfeasibilitylIssue\n\nThe InfeasibleConstraintRange issue is identified when a constraint cannot be satisfied given the variable bounds. This analysis only considers one constraint at a time and all variable bounds of variables involved in the constraint. This issue can only be found is all variable bounds are consistent, that is, no issues of type InfeasibleBounds were found in the first layer of analysis.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(\n    ModelAnalyzer.Infeasibility.InfeasibleConstraintRange\n)\n\n\n\n\n\n","category":"type"},{"location":"infeasibility/#ModelAnalyzer.Infeasibility.IrreducibleInfeasibleSubset","page":"Infeasibility Analysis","title":"ModelAnalyzer.Infeasibility.IrreducibleInfeasibleSubset","text":"IrreducibleInfeasibleSubset <: AbstractInfeasibilitylIssue\n\nThe IrreducibleInfeasibleSubset issue is identified when a subset of constraints cannot be satisfied simultaneously. This is typically found by the IIS resolver after the first two layers of infeasibility analysis have been completed with no issues, that is, no issues of any other type were found.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(\n    ModelAnalyzer.Infeasibility.IrreducibleInfeasibleSubset\n)\n\n\n\n\n\n","category":"type"},{"location":"infeasibility/","page":"Infeasibility Analysis","title":"Infeasibility Analysis","text":"These issues are saved in the data structure that is returned from the ModelAnalyzer.analyze function:","category":"page"},{"location":"infeasibility/#ModelAnalyzer.Infeasibility.Data","page":"Infeasibility Analysis","title":"ModelAnalyzer.Infeasibility.Data","text":"Data <: ModelAnalyzer.AbstractData\n\nThe Data type is used to store the results of the infeasibility analysis. This type contains vectors of the various infeasibility issues found during the analysis, including InfeasibleBounds, InfeasibleIntegrality, InfeasibleConstraintRange, and IrreducibleInfeasibleSubset.\n\n\n\n\n\n","category":"type"},{"location":"numerical/#Numerical-Analysis","page":"Numerical Analysis","title":"Numerical Analysis","text":"","category":"section"},{"location":"numerical/","page":"Numerical Analysis","title":"Numerical Analysis","text":"This module provides functionality to perform numerical analysis on a JuMP model. This module follows the main API and is activated by the struct:","category":"page"},{"location":"numerical/#ModelAnalyzer.Numerical.Analyzer","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.Analyzer","text":"Analyzer() <: ModelAnalyzer.AbstractAnalyzer\n\nThe Analyzer type is used to analyze the coefficients of a model for numerical issues.\n\nExample\n\njulia> data = ModelAnalyzer.analyze(\n    ModelAnalyzer.Numerical.Analyzer(),\n    model;\n    threshold_dense_fill_in = 0.10,\n    threshold_dense_entries = 1000,\n    threshold_small = 1e-5,\n    threshold_large = 1e+5,\n)\n\nThe additional parameters:\n\nthreshold_dense_fill_in: The threshold for the fraction of non-zero entries in a constraint to be considered dense.\nthreshold_dense_entries: The minimum number of non-zero entries for a constraint to be considered dense.\nthreshold_small: The threshold for small coefficients in the model.\nthreshold_large: The threshold for large coefficients in the model.\n\n\n\n\n\n","category":"type"},{"location":"numerical/","page":"Numerical Analysis","title":"Numerical Analysis","text":"The analysis will return issues of the abstract type:","category":"page"},{"location":"numerical/#ModelAnalyzer.Numerical.AbstractNumericalIssue","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.AbstractNumericalIssue","text":"AbstractNumericalIssue <: AbstractNumericalIssue\n\nAbstract type for numerical issues found during the analysis of a model.\n\n\n\n\n\n","category":"type"},{"location":"numerical/","page":"Numerical Analysis","title":"Numerical Analysis","text":"Specifically the possible issues are:","category":"page"},{"location":"numerical/#ModelAnalyzer.Numerical.VariableNotInConstraints","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.VariableNotInConstraints","text":"VariableNotInConstraints <: AbstractNumericalIssue\n\nThe VariableNotInConstraints issue is identified when a variable appears in no constraints.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Numerical.VariableNotInConstraints)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#ModelAnalyzer.Numerical.EmptyConstraint","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.EmptyConstraint","text":"EmptyConstraint <: AbstractNumericalIssue\n\nThe EmptyConstraint issue is identified when a constraint has no coefficients different from zero.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Numerical.EmptyConstraint)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#ModelAnalyzer.Numerical.VariableBoundAsConstraint","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.VariableBoundAsConstraint","text":"VariableBoundAsConstraint <: AbstractNumericalIssue\n\nThe VariableBoundAsConstraint issue is identified when a constraint is equivalent to a variable bound, that is, the constraint has only one non-zero coefficient, and this coefficient is equal to one.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Numerical.VariableBoundAsConstraint)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#ModelAnalyzer.Numerical.DenseConstraint","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.DenseConstraint","text":"DenseConstraint <: AbstractNumericalIssue\n\nThe DenseConstraint issue is identified when a constraint has a fraction of non-zero entries greater than threshold_dense_fill_in and the number of non-zero entries is greater than threshold_dense_entries.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Numerical.DenseConstraint)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#ModelAnalyzer.Numerical.SmallMatrixCoefficient","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.SmallMatrixCoefficient","text":"SmallMatrixCoefficient <: AbstractNumericalIssue\n\nThe SmallMatrixCoefficient issue is identified when a matrix coefficient in a constraint is smaller than threshold_small.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Numerical.SmallMatrixCoefficient)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#ModelAnalyzer.Numerical.LargeMatrixCoefficient","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.LargeMatrixCoefficient","text":"LargeMatrixCoefficient <: AbstractNumericalIssue\n\nThe LargeMatrixCoefficient issue is identified when a matrix coefficient in a constraint is larger than threshold_large.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Numerical.LargeMatrixCoefficient)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#ModelAnalyzer.Numerical.SmallBoundCoefficient","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.SmallBoundCoefficient","text":"SmallBoundCoefficient <: AbstractNumericalIssue\n\nThe SmallBoundCoefficient issue is identified when a variable's bound (coefficient) is smaller than threshold_small.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Numerical.SmallBoundCoefficient)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#ModelAnalyzer.Numerical.LargeBoundCoefficient","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.LargeBoundCoefficient","text":"LargeBoundCoefficient <: AbstractNumericalIssue\n\nThe LargeBoundCoefficient issue is identified when a variable's bound (coefficient) is larger than threshold_large.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Numerical.LargeBoundCoefficient)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#ModelAnalyzer.Numerical.SmallRHSCoefficient","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.SmallRHSCoefficient","text":"SmallRHSCoefficient <: AbstractNumericalIssue\n\nThe SmallRHSCoefficient issue is identified when the right-hand-side (RHS) coefficient of a constraint is smaller than threshold_small.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Numerical.SmallRHSCoefficient)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#ModelAnalyzer.Numerical.LargeRHSCoefficient","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.LargeRHSCoefficient","text":"LargeRHSCoefficient <: AbstractNumericalIssue\n\nThe LargeRHSCoefficient issue is identified when the right-hand-side (RHS) coefficient of a constraint is larger than threshold_large.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Numerical.LargeRHSCoefficient)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#ModelAnalyzer.Numerical.SmallObjectiveCoefficient","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.SmallObjectiveCoefficient","text":"SmallObjectiveCoefficient <: AbstractNumericalIssue\n\nThe SmallObjectiveCoefficient issue is identified when a coefficient in the objective function is smaller than threshold_small.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Numerical.SmallObjectiveCoefficient)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#ModelAnalyzer.Numerical.LargeObjectiveCoefficient","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.LargeObjectiveCoefficient","text":"LargeObjectiveCoefficient <: AbstractNumericalIssue\n\nThe LargeObjectiveCoefficient issue is identified when a coefficient in the objective function is larger than threshold_large.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(ModelAnalyzer.Numerical.LargeObjectiveCoefficient)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#ModelAnalyzer.Numerical.SmallObjectiveQuadraticCoefficient","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.SmallObjectiveQuadraticCoefficient","text":"SmallObjectiveQuadraticCoefficient <: AbstractNumericalIssue\n\nThe SmallObjectiveQuadraticCoefficient issue is identified when a quadratic coefficient in the objective function is smaller than threshold_small.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(\n    ModelAnalyzer.Numerical.SmallObjectiveQuadraticCoefficient\n)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#ModelAnalyzer.Numerical.LargeObjectiveQuadraticCoefficient","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.LargeObjectiveQuadraticCoefficient","text":"LargeObjectiveQuadraticCoefficient <: AbstractNumericalIssue\n\nThe LargeObjectiveQuadraticCoefficient issue is identified when a quadratic coefficient in the objective function is larger than threshold_large.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(\n    ModelAnalyzer.Numerical.LargeObjectiveQuadraticCoefficient\n)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#ModelAnalyzer.Numerical.SmallMatrixQuadraticCoefficient","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.SmallMatrixQuadraticCoefficient","text":"SmallMatrixQuadraticCoefficient <: AbstractNumericalIssue\n\nThe SmallMatrixQuadraticCoefficient issue is identified when a quadratic coefficient in a constraint is smaller than threshold_small.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(\n    ModelAnalyzer.Numerical.SmallMatrixQuadraticCoefficient\n)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#ModelAnalyzer.Numerical.LargeMatrixQuadraticCoefficient","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.LargeMatrixQuadraticCoefficient","text":"LargeMatrixQuadraticCoefficient <: AbstractNumericalIssue\n\nThe LargeMatrixQuadraticCoefficient issue is identified when a quadratic coefficient in a constraint is larger than threshold_large.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(\n    ModelAnalyzer.Numerical.LargeMatrixQuadraticCoefficient\n)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#ModelAnalyzer.Numerical.NonconvexQuadraticObjective","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.NonconvexQuadraticObjective","text":"NonconvexQuadraticObjective <: AbstractNumericalIssue\n\nThe NonconvexQuadraticObjective issue is identified when a quadratic objective function is non-convex.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(\n    ModelAnalyzer.Numerical.NonconvexQuadraticObjective\n)\n\n\n\n\n\n","category":"type"},{"location":"numerical/#ModelAnalyzer.Numerical.NonconvexQuadraticConstraint","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.NonconvexQuadraticConstraint","text":"NonconvexQuadraticConstraint\n\nThe NonconvexQuadraticConstraint issue is identified when a quadratic constraint is non-convex.\n\nFor more information, run:\n\njulia> ModelAnalyzer.summarize(\n    ModelAnalyzer.Numerical.NonconvexQuadraticConstraint\n)\n\n\n\n\n\n","category":"type"},{"location":"numerical/","page":"Numerical Analysis","title":"Numerical Analysis","text":"These issues are saved in the data structure that is returned from the ModelAnalyzer.analyze function:","category":"page"},{"location":"numerical/#ModelAnalyzer.Numerical.Data","page":"Numerical Analysis","title":"ModelAnalyzer.Numerical.Data","text":"Data\n\nThe Data structure holds the results of the analysis performed by the ModelAnalyzer.Numerical.Analyzer. It contains various thresholds and the information about the model's variables, constraints, and objective function.\n\n\n\n\n\n","category":"type"},{"location":"#ModelAnalyzer.jl","page":"ModelAnalyzer.jl","title":"ModelAnalyzer.jl","text":"","category":"section"},{"location":"","page":"ModelAnalyzer.jl","title":"ModelAnalyzer.jl","text":"This package provides tools for analyzing (and debugging) JuMP models.","category":"page"},{"location":"","page":"ModelAnalyzer.jl","title":"ModelAnalyzer.jl","text":"Three main functionalities are provided:","category":"page"},{"location":"","page":"ModelAnalyzer.jl","title":"ModelAnalyzer.jl","text":"Numerical Analysis: Check for numerical issues in the model, such as large and small coefficients, empty constraints, non-convex quadratic functions.\nFeasibility Analysis: Given an optimized model, or a candidate solution, check if the solutions is feasible and optimal (when possible). This includes checking the feasibility of the primal model and also the dual model (if available). Complementary slackness conditions are also checked (if applicable).\nInfeasibility Analysis: Given an unsolved of solved model, three steps are made to check for infeasibility:\nCheck bounds, integers and binaries consistency is also checked at this point.\nPropagate bounds in constraints individually, to check if each constraint is infeasible given the current variable bounds. This is only done if bounds are ok.\nRun an IIS (Irreducible Inconsistent Subsystem / irreducible infeasible sets) resolver algorithm to find a minimal infeasible subset of constraints. This is only done if no issues are found in the previous two steps.","category":"page"},{"location":"#Installation","page":"ModelAnalyzer.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"ModelAnalyzer.jl","title":"ModelAnalyzer.jl","text":"You can install the package using the Julia package manager. In the Julia REPL, run:","category":"page"},{"location":"","page":"ModelAnalyzer.jl","title":"ModelAnalyzer.jl","text":"using Pkg\nPkg.add(url = \"https://github.com/jump-dev/ModelAnalyzer.jl\")","category":"page"},{"location":"#Usage","page":"ModelAnalyzer.jl","title":"Usage","text":"","category":"section"},{"location":"#Basic-usage","page":"ModelAnalyzer.jl","title":"Basic usage","text":"","category":"section"},{"location":"","page":"ModelAnalyzer.jl","title":"ModelAnalyzer.jl","text":"Here is a simple example of how to use the package:","category":"page"},{"location":"","page":"ModelAnalyzer.jl","title":"ModelAnalyzer.jl","text":"using JuMP\nusing ModelAnalyzer\nusing HiGHS # or any other supported solver\n# Create a simple JuMP model\nmodel = Model(HiGHS.Optimizer)\n@variable(model, x >= 0)\n@variable(model, y >= 0)\n@constraint(model, c1, 2x + 3y == 5)\n@constraint(model, c2, x + 2y <= 3)\n@objective(model, Min, x + y)\n# Optimize the model\noptimize!(model)\n\n# either\n\n# Perform a numerical analysis of the model\ndata = ModelAnalyzer.analyze(ModelAnalyzer.Numerical.Analyzer(), model)\n# print report\nModelAnalyzer.summarize(data)\n\n# or\n\n# Check for solution feasibility and optimality\ndata = ModelAnalyzer.analyze(ModelAnalyzer.Feasibility.Analyzer(), model)\n# print report\nModelAnalyzer.summarize(data)\n\n# or\n\n# Infeasibility analysis (if the model was infeasible)\ndata = ModelAnalyzer.analyze(\n    ModelAnalyzer.Infeasibility.Analyzer(),\n    model,\n    optimizer = HiGHS.Optimizer,\n)\n\n# print report to the screen\nModelAnalyzer.summarize(data)\n\n# or print ehte report to a file\n\n# open a file\nopen(\"my_report.txt\", \"w\") do io\n    # print report\n    ModelAnalyzer.summarize(io, data)\nend","category":"page"},{"location":"","page":"ModelAnalyzer.jl","title":"ModelAnalyzer.jl","text":"The ModelAnalyzer.analyze(...) function can always take the keyword arguments:","category":"page"},{"location":"","page":"ModelAnalyzer.jl","title":"ModelAnalyzer.jl","text":"verbose = false to condense the print output.\nmax_issues = n to limit the maximum number of issues to report for each type.","category":"page"},{"location":"","page":"ModelAnalyzer.jl","title":"ModelAnalyzer.jl","text":"For certain analysis modes, the summarize function can take additional arguments.","category":"page"},{"location":"#Advanced-usage","page":"ModelAnalyzer.jl","title":"Advanced usage","text":"","category":"section"},{"location":"","page":"ModelAnalyzer.jl","title":"ModelAnalyzer.jl","text":"After any ModelAnalyzer.analyze(...) call is performed, the resulting data structure can be summarized using ModelAnalyzer.summarize(data) as show above, or it can be further inspected programmatically.","category":"page"},{"location":"","page":"ModelAnalyzer.jl","title":"ModelAnalyzer.jl","text":"# given a `data` object obtained from `ModelAnalyzer.analyze(...)`\n\n# query the types os issues found in the analysis\nlist = ModelAnalyzer.list_of_issue_types(data)\n\n# information about the types of issues found can be printed out\nModelAnalyzer.summarize(list[1])\n\n# for each issue type, you can get the actual issues found in the analysis\nissues = ModelAnalyzer.list_of_issues(data, list[1])\n\n# the list of issues of the given type can be summarized with:\nModelAnalyzer.summarize(issues)\n\n# individual issues can also be summarized\nModelAnalyzer.summarize(issues[1])","category":"page"}]
}
